// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc157.FRC2016.subsystems;

import org.usfirst.frc157.FRC2016.RobotMap;
import org.usfirst.frc157.FRC2016.commands.*;
import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.CANTalon.FeedbackDevice;
import edu.wpi.first.wpilibj.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 *
 */
public class Arm extends Subsystem {

	public enum Position
	{
		FULL_DOWN           (-20.0),  // Minimum Shoulder Angle
		FRENCH_FRIES_DOWN   (-15.0),  // Push down fries to this Angle before crossing
		GRAB_BOULDER        (-12.0),  // Angle to use to grab a boulder
		LOW_BAR_TRAVEL      (-10.0),  // Angle to use to go under low bar
		PREPARE_FOR_BOULDER (10.0),   // Normal Bar Angle (ready to grab boulder)
		HOME                (0.0),    // Starting Angle is defined as 0, all other angles are referenced to it ~30 degrees
		GAME_START          (0.0),    // Game Start Angle (arm is inside legal starting box) 
		DRAWBRIDGE_GRAB     (20.0),   // Angle required to start Drawbridge Grab
		TOWER_SCALE         (50.0),   // Angle to use to extend ladder to scale tower
		FULL_UP             (70.0);   // Maximum shoulder Angle

		private final double angle;  // in degrees

		Position(double angle) {
			this.angle = angle;
		}
		
		double angle()
		{
			// returns the angle associated with the position
			return this.angle;
		}
	}
	
	public enum ArmMode
	{
		AUTOMATIC,
		MANUAL;
	}

	
	private ArmMode armMode;
	
	// TODO fix Arm subsystem to use TALON itegrated control loop instead of roboRio control loop
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon shoulderMotor = RobotMap.armShoulderMotor;
    private final CANTalon extenderMotorA = RobotMap.armExtenderMotorA;
    private final CANTalon extenderMotorB = RobotMap.armExtenderMotorB;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Initialize your subsystem here
    public Arm() {
    	setShoulderMode(ArmMode.AUTOMATIC);
    	setExtenderMode(ArmMode.AUTOMATIC);
    }

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
     
    // TODO finish this code...
    public boolean setShoulderMode(ArmMode mode)
    {
    	switch(mode)
    	{
    	case MANUAL:
    		armMode = ArmMode.MANUAL;
    		shoulderMotor.changeControlMode(TalonControlMode.PercentVbus);
    		break;
    	case AUTOMATIC:
    	default:           // Unknown modes will be treated as automatic
    		armMode = ArmMode.AUTOMATIC;
    		shoulderMotor.changeControlMode(TalonControlMode.Position);
    		shoulderMotor.setFeedbackDevice(FeedbackDevice.QuadEncoder);
    		break;
    	}
    	return true;
    }
    
    public boolean setExtenderMode(ArmMode mode)
    {
    	switch(mode)
    	{
    	case MANUAL:
    		armMode = ArmMode.MANUAL;
    		break;
    	case AUTOMATIC:
    	default:           // Unknown modes will be treated as automatic
    		armMode = ArmMode.AUTOMATIC;
    		break;
    	}
    	extenderMotorB.changeControlMode(CANTalon.TalonControlMode.Follower);
       	extenderMotorB.set(extenderMotorA.getDeviceID());
  
    	return true;
    }

    public boolean gotoAngle(double angle)
    {
    	return true;
    }
    
    public boolean gotoPosition(Position position)
    {
    	return gotoAngle(position.angle());
    }
}
